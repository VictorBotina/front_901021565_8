
import fs from 'fs';
import path from 'path';

const APP_DIR = path.join(process.cwd(), 'src', 'app');
const OUTPUT_FILE = path.join(process.cwd(), 'src', 'lib', 'search-data.ts');

const ICONS_MAP = {
  afiliados: 'Users',
  subsidiado: 'File',
  contributivo: 'File',
  prestadores: 'HeartHandshake',
  blog: 'Newspaper',
  nosotros: 'Building',
  colaboradores: 'Users',
  normatividad: 'Book',
  'tramites-en-linea': 'Workflow',
  'consulta-ips': 'HeartHandshake',
  oficinas: 'Map',
  informacion: 'Book',
  'cuidado-de-la-salud': 'HeartPulse',
  'canales-de-atencion': 'Phone',
  tramites: 'File',
  'derechos-y-deberes': 'Book',
  'plan-de-beneficios': 'Book',
  afiliacion: 'File',
  certificados: 'File',
  movilidad: 'File',
  nutricion: 'Apple',
  'salud-mental': 'BrainCircuit',
  default: 'File',
};

function findPages(dir) {
  let results = [];
  const list = fs.readdirSync(dir);
  list.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    if (stat && stat.isDirectory()) {
      results = results.concat(findPages(filePath));
    } else if (file === 'page.tsx') {
      results.push(filePath);
    }
  });
  return results;
}

function extractMetadata(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const metadataRegex = /export\s+const\s+metadata\s*:\s*Metadata\s*=\s*({(?:.|\n)*?});/;
    const match = content.match(metadataRegex);

    if (!match) {
      return null;
    }

    const metadataStr = match[1];
    const keywordsMatch = metadataStr.match(/keywords:\s*\[([^\]]*)\]/);
    const titleMatch = metadataStr.match(/title:\s*['"](.*?)['"]/);
    
    if (!keywordsMatch) {
      return null;
    }

    const keywords = keywordsMatch[1]
      .split(',')
      .map(k => k.trim().replace(/['"]/g, ''))
      .filter(Boolean);

    if (keywords.length === 0) {
      return null;
    }

    const title = titleMatch ? titleMatch[1] : path.basename(path.dirname(filePath));

    return { title, keywords };

  } catch (error) {
    console.error(`Error reading or parsing ${filePath}:`, error);
    return null;
  }
}

function getIconForPath(slug) {
    const firstSegment = slug.split('/')[1] || 'default';
    return ICONS_MAP[firstSegment] || ICONS_MAP.default;
}

function generateSearchIndex() {
  const pageFiles = findPages(APP_DIR);
  const searchIndex = [];

  // Add homepage manually
  searchIndex.push({
    title: 'Inicio',
    href: '/',
    keywords: ['home', 'principal', 'dashboard', 'inicio'],
    icon: 'Home',
  });

  pageFiles.forEach(filePath => {
    const metadata = extractMetadata(filePath);
    if (metadata) {
      let href = path.relative(APP_DIR, filePath)
        .replace(/\\/g, '/')
        .replace(/\/page\.tsx$/, '')
        .replace(/^\(.*\)\//, ''); // Remove route groups like (home)/
      
      if (href === 'page.tsx') href = '';
      
      href = '/' + href;

      searchIndex.push({
        title: metadata.title,
        href,
        keywords: metadata.keywords,
        icon: getIconForPath(href),
      });
    }
  });
  
  const fileContent = `// This file is auto-generated by scripts/generate-search-index.mjs
// Do not edit this file directly.

export type SearchablePage = {
  title: string;
  href: string;
  keywords: string[];
  icon: string;
};

export const searchData: SearchablePage[] = ${JSON.stringify(searchIndex, null, 2)};
`;

  fs.writeFileSync(OUTPUT_FILE, fileContent);
  console.log(`âœ… Search index generated successfully with ${searchIndex.length} pages.`);
}

generateSearchIndex();
